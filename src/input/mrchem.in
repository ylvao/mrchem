#!/usr/bin/env python

#
# MRChem, a numerical real-space code for molecular electronic structure
# calculations within the self-consistent field (SCF) approximations of quantum
# chemistry (Hartree-Fock and Density Functional Theory).
# Copyright (C) 2019 Stig Rune Jensen, Luca Frediani, Peter Wind and contributors.
#
# This file is part of MRChem.
#
# MRChem is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# MRChem is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with MRChem.  If not, see <https://www.gnu.org/licenses/>.
#
# For information on the complete list of contributors to MRChem, see:
# <https://mrchem.readthedocs.io/>
#

import json
import math
import optparse
import os
import re
import subprocess
import sys
import tempfile
from io import StringIO
from pathlib import Path

# FIXME This will pick up modules when installed
sys.path.append("@CMAKE_INSTALL_PREFIX@/@PYTHON_SITE_INSTALL_DIR@")
sys.path.append('@PROJECT_SOURCE_DIR@/src/chemistry')

from parselglossy.api import parse
from periodictable import PeriodicTable as PT


def main():
    this_path = Path(__file__).parent

    # create necessary directories
    for d in ['orbitals', 'initial_guess', 'plots']:
        if not os.path.exists(d):
            os.mkdir(d)

    # Parse command line
    executable, dryrun, inp_file_cmd = parse_cmdline()

    in_path = Path(inp_file_cmd)
    tmpl_path = Path('@PROJECT_SOURCE_DIR@/src/input/template.yml')

    # read user input file (JSONDict <- getkw file)
    user_dict = parse(infile=in_path, template=tmpl_path, grammar='getkw')

    # now that all keywords have sensible values,
    # we can translate user input into program input
    program_dict = translate_input(user_dict)

    inp_name, ext_ext = os.path.splitext(inp_file_cmd)
    xfile = inp_name + '.json'
    with open(xfile, 'w') as fd:
        fd.write(json.dumps(program_dict, indent=2))

    if not dryrun:
        cmd = executable + ' ' + xfile
        if program_dict["printer"]["print_input"]:
            subprocess.call('cat ' + inp_file_cmd, shell=True)
        subprocess.call(cmd, shell=True)

def parse_cmdline():
    usage = "usage: %prog [options] [config] inp_file"
    version = "@PROGRAM_VERSION@"
    cmdln = optparse.OptionParser(
        usage=usage, version="%prog {0}".format(version))
    cmdln.add_option(
        '-D',
        '--dryrun',
        action='store_true',
        dest='dryrun',
        default=False,
        help='Only process input')
    cmdln.add_option(
        '-x',
        '--executable',
        action='store',
        dest='executable',
        type='string',
        default='@MRCHEM_EXECUTABLE@',
        help='set executable name')

    opts, args = cmdln.parse_args()

    executable = opts.executable
    dryrun = opts.dryrun

    if (len(args) == 0):
        cmdln.error('No input file passed!')
        sys.exit(1)
    elif (len(args) == 1):
        inp_file = args[0]
    else:
        cmdln.error('Incorrect number of files')
        sys.exit(1)

    return executable, dryrun, inp_file

def translate_input(user_dict):
  program_dict = {}
  write_mpi(program_dict, user_dict);
  write_printer(program_dict, user_dict);
  write_molecule(program_dict, user_dict);
  write_mra(program_dict, user_dict);
  write_initial_guess(program_dict, user_dict);
  write_scf_calculation(program_dict, user_dict);
  write_rsp_calculations(program_dict, user_dict);
  return program_dict

def write_mpi(program_dict, user_dict):
  program_dict["mpi"] = {
    "numerically_exact": user_dict["MPI"]["numerically_exact"],
    "shared_memory_size": user_dict["MPI"]["shared_memory_size"]
  }

def write_mra(program_dict, user_dict):
  order = user_dict["Basis"]["order"]
  if order < 0:
    # Set polynomial order based on world_prec
    prec = user_dict["world_prec"]
    order = int(math.ceil(-1.5 * math.log10(prec)))

  min_scale = -(user_dict["world_size"] - 1)
  if min_scale > 1:
    # Compute auto box
    max_coord = 0.0 # single (coord + Z) with largest abs value
    for coord in program_dict["molecule"]["coords"]:
      Z_i = max(6.0, float(PT[coord["atom"]].Z))
      max_coord = max(max_coord, abs(max(coord["xyz"], key=abs)) + Z_i)

    min_scale = 0
    while 2.0**(-min_scale) < max_coord:
      min_scale = min_scale - 1

  max_scale = 20
  if (max_scale - min_scale) > 30:
    max_scale = 30 + min_scale

  program_dict["mra"] = {
    "basis_type": user_dict["Basis"]["type"][0].lower(),
    "order": order,
    "boxes": [2, 2, 2],
    "corner": [-1, -1, -1],
    "min_scale": min_scale,
    "max_scale": max_scale,
    "scaling_factor": [1.0, 1.0, 1.0]
  }

def write_printer(program_dict, user_dict):
  program_dict["printer"] = user_dict["Printer"]

def write_molecule(program_dict, user_dict):
  # Translate into program syntax
  coords_raw = user_dict["Molecule"]["coords"]
  coords_dict = []
  for line in coords_raw.split('\n'):
    sp = line.split()
    if len(sp) > 0:
      atom = sp[0].lower()
      xyz = list(map(float, sp[1:]))
      if len(xyz) != 3:
        print("Invalid coordinate: " + atom.upper() + " " + str(xyz))
        sys.exit(1)
      coords_dict.append({
        "atom": atom,
        "xyz": xyz
      })

  # Convert angstrom -> bohr
  if user_dict["Molecule"]["angstrom"]:
    AA = 1.889725989
    for coord in coords_dict:
      coord["xyz"] = [AA * r for r in coord["xyz"]]

  # Translate center of mass to origin
  if user_dict["Molecule"]["translate"]:
    # Calc center of mass
    M = 0.0
    CoM = [0.0, 0.0, 0.0]
    for coord in coords_dict:
      m = PT[coord["atom"]].mass
      M += m
      CoM = [m*r + o for r,o in zip(coord["xyz"], CoM)]
    CoM = [x/M for x in CoM]

    # Translate coords
    for coord in coords_dict:
      coord["xyz"] = [r - o for r,o in zip(coord["xyz"], CoM)]

  program_dict["molecule"] = {
    "charge": user_dict["Molecule"]["charge"],
    "multiplicity": user_dict["Molecule"]["multiplicity"],
    "coords": coords_dict
  }


def write_initial_guess(program_dict, user_dict):
  guess_str = user_dict["SCF"]["initial_guess"].lower()
  method = guess_str.split('_')[0]
  zeta = 0
  if method == 'sad' or method == 'core':
    zeta_str = guess_str.split('_')[1]
    if zeta_str == 'sz':
      zeta = 1
    elif zeta_str == 'dz':
      zeta = 2
    elif zeta_str == 'tz':
      zeta = 3
    elif zeta_str == 'qz':
      zeta = 4
    else:
      print("Invalid zeta:" + guess_suffix)

  program_dict["initial_guess"] = {
    "restricted": user_dict["WaveFunction"]["restricted"],
    "guess_prec": user_dict["SCF"]["guess_prec"],
    "method": method,
    "zeta": zeta,
    "start_orbitals": "orbitals/phi",
    "final_orbitals": "orbitals/phi",
    "file_basis": "initial_guess/mrchem.bas",
    "file_moa": "initial_guess/mrchem.moa",
    "file_mob": "initial_guess/mrchem.mob",
    "write_orbitals": False
  }

def write_scf_calculation(program_dict, user_dict):
  # SCF precisions and thresholds
  if user_dict["SCF"]["orbital_thrs"] < 0.0 and user_dict["SCF"]["property_thrs"] < 0.0:
    user_dict["SCF"]["property_thrs"] = user_dict["world_prec"] / 10
    user_dict["SCF"]["orbital_thrs"] = math.sqrt(user_dict["SCF"]["property_thrs"])

  if user_dict["KineticFree"]["orbital_thrs"] < 0.0 and user_dict["KineticFree"]["property_thrs"] < 0.0:
    user_dict["KineticFree"]["property_thrs"] = user_dict["world_prec"] / 10
    user_dict["KineticFree"]["orbital_thrs"] = math.sqrt(user_dict["KineticFree"]["property_thrs"])

  scf_dict = {
    "final_orbitals": "orbitals/phi",
    "write_orbitals": user_dict["SCF"]["write_orbitals"],
  }
  prop_dict = {
   "dipole_moment": {
      "setup_prec": user_dict["world_prec"],
      "origin": [0.0, 0.0, 0.0]
    }
  }

  scf_dict["cube_plot"] = {
      "density": user_dict["SCF"]["plot_density"],
      "orbital": user_dict["SCF"]["plot_orbital"],
      "plotter": user_dict["Plotter"]
  }

  if user_dict["Properties"]["dipole_moment"]:
    scf_dict["properties"] = prop_dict

  method_name = ''
  if (user_dict["WaveFunction"]["method"].lower() == "hartree"):
    method_name = 'Hartree'
  if (user_dict["WaveFunction"]["method"].lower() == "hf"):
    method_name = 'Hartree-Fock'
  if (user_dict["WaveFunction"]["method"].lower() == "dft"):
    method_name = 'DFT'

  if user_dict["SCF"]["run"]:
    scf_dict["initial_energy"] = {
      "method_name": method_name,
      "localize": user_dict["SCF"]["localize"],
      "prec": user_dict["SCF"]["orbital_prec"][0],
    }
    scf_dict["orbital_solver"] = {
      "method_name": method_name,
      "kain": user_dict["SCF"]["kain"],
      "max_iter": user_dict["SCF"]["max_iter"],
      "rotation": user_dict["SCF"]["rotation"],
      "localize": user_dict["SCF"]["localize"],
      "start_prec": user_dict["SCF"]["orbital_prec"][0],
      "final_prec": user_dict["SCF"]["orbital_prec"][1],
      "orbital_thrs": user_dict["SCF"]["orbital_thrs"],
      "property_thrs": user_dict["SCF"]["property_thrs"]
    }
  else:
    scf_dict["initial_energy"] = {
      "method_name": method_name,
      "localize": user_dict["SCF"]["localize"],
      "prec": user_dict["SCF"]["orbital_prec"][1],
    }
  if user_dict["KineticFree"]["run"]:
    scf_dict["energy_solver"] = {
      "method_name": method_name,
      "max_iter": user_dict["KineticFree"]["max_iter"],
      "localize": user_dict["KineticFree"]["localize"],
      "start_prec": user_dict["world_prec"],
      "final_prec": user_dict["world_prec"],
      "orbital_thrs": user_dict["KineticFree"]["orbital_thrs"],
      "property_thrs": user_dict["KineticFree"]["property_thrs"]
    }

  fock_dict = {
    "kinetic_operator": {
      "derivative": user_dict["Derivatives"]["kinetic"]
    },
    "nuclear_operator": {
      "proj_prec": user_dict["Precisions"]["nuc_prec"],
      "smooth_prec": user_dict["Precisions"]["nuc_prec"],
      "shared_memory": user_dict["MPI"]["share_nuclear_potential"]
    }
  }

  if (user_dict["WaveFunction"]["method"].lower() == "hartree" or
      user_dict["WaveFunction"]["method"].lower() == "hf" or
      user_dict["WaveFunction"]["method"].lower() == "dft"):
    fock_dict["coulomb_operator"] = {
      "poisson_prec": user_dict["Precisions"]["poisson_prec"],
      "shared_memory": user_dict["MPI"]["share_coulomb_potential"]
    }
  if user_dict["WaveFunction"]["method"].lower() == "hf":
    fock_dict["exchange_operator"] = {
      "screen": False,
      "poisson_prec": user_dict["Precisions"]["poisson_prec"]
    }

  if user_dict["WaveFunction"]["method"].lower() == "dft":
    func_raw = user_dict["DFT"]["functionals"]
    func_dict = []
    exx = False
    for line in func_raw.split('\n'):
      sp = line.split()
      if len(sp) > 0:
        func = sp[0].lower()
        coef = [1.0]
        if len(sp) > 1:
          coef = list(map(float, sp[1:]))
        func_dict.append({
          "name": func,
          "coef": coef[0]
        })
        if func == "exx":
          exx = True
    fock_dict["xc_operator"] = {
      "grid_prec": user_dict["Precisions"]["dft_prec"],
      "shared_memory": user_dict["MPI"]["share_xc_potential"],
      "xc_functional": {
        "spin": user_dict["DFT"]["spin"],
        "gamma": user_dict["DFT"]["use_gamma"],
        "cutoff": user_dict["DFT"]["density_cutoff"],
        "derivative": user_dict["Derivatives"]["dft"],
        "functionals": func_dict
      }
    }
    if exx:
      fock_dict["exchange_operator"] = {
        "screen": False,
        "poisson_prec": user_dict["Precisions"]["poisson_prec"]
      }
  if user_dict["ExternalField"]["electric_run"]:
    fock_dict["external_operator"] = {
      "electric_field": user_dict["ExternalField"]["electric_field"],
      "origin": [0.0, 0.0, 0.0]
    }
  if user_dict["ExternalField"]["magnetic_run"]:
    fock_dict["external_operator"] = {
      "magnetic_field": user_dict["ExternalField"]["magnetic_field"],
      "origin": [0.0, 0.0, 0.0]
    }

  scf_dict["fock_operator"] = fock_dict
  program_dict["scf_calculation"] = scf_dict

def write_rsp_calculations(program_dict, user_dict):
  program_dict["rsp_calculations"] = []

  if user_dict["Properties"]["polarizability"]:
    for omega in user_dict["Polarizability"]["frequency"]:
      rsp_dict = {
        "rsp_prec": user_dict["world_prec"],
        "localize": user_dict["Response"]["localize"],
        "dynamic": (omega > 1.0e-12),
        "final_orbitals": "orbitals/phi_x",
        "write_orbitals": user_dict["Response"]["write_orbitals"],
        "perturbation": {
          "operator": "h_e_dip",
          "origin": [0.0, 0.0, 0.0]
        }
      }
      prop_dict = {
       "polarizability": {
          "setup_prec": user_dict["world_prec"],
          "origin": [0.0, 0.0, 0.0]
        }
      }
      rsp_dict["properties"] = prop_dict

      if user_dict["Response"]["run"]:
        rsp_dict["rsp_solver"] = {
          "frequency": omega,
          "kain": user_dict["Response"]["kain"],
          "max_iter": user_dict["Response"]["max_iter"],
          "start_prec": user_dict["Response"]["orbital_prec"][0],
          "final_prec": user_dict["Response"]["orbital_prec"][1],
          "directions": user_dict["Response"]["directions"],
          "orbital_thrs": user_dict["Response"]["orbital_thrs"],
          "property_thrs": user_dict["Response"]["property_thrs"]
        }

      fock_0_dict = {
        "kinetic_operator": {
          "derivative": user_dict["Derivatives"]["kinetic"]
        },
        "nuclear_operator": {
          "proj_prec": user_dict["Precisions"]["nuc_prec"],
          "smooth_prec": user_dict["Precisions"]["nuc_prec"],
          "shared_memory": user_dict["MPI"]["share_nuclear_potential"]
        }
      }
      if (user_dict["WaveFunction"]["method"].lower() == "hartree" or
          user_dict["WaveFunction"]["method"].lower() == "hf" or
          user_dict["WaveFunction"]["method"].lower() == "dft"):
        fock_0_dict["coulomb_operator"] = {
          "poisson_prec": user_dict["Precisions"]["poisson_prec"],
          "shared_memory": user_dict["MPI"]["share_coulomb_potential"]
        }
      if user_dict["WaveFunction"]["method"].lower() == "hf":
        fock_0_dict["exchange_operator"] = {
          "screen": False,
          "poisson_prec": user_dict["Precisions"]["poisson_prec"],
        }

      if user_dict["WaveFunction"]["method"].lower() == "dft":
        func_raw = user_dict["DFT"]["functionals"]
        func_dict = []
        exx = False
        for line in func_raw.split('\n'):
          sp = line.split()
          if len(sp) > 0:
            func = sp[0].lower()
            coef = [1.0]
            if len(sp) > 1:
              coef = list(map(float, sp[1:]))
            func_dict.append({
              "name": func,
              "coef": coef[0]
            })
            if func == "exx":
              exx = True
        fock_0_dict["xc_operator"] = {
          "grid_prec": user_dict["Precisions"]["dft_prec"],
          "shared_memory": user_dict["MPI"]["share_xc_potential"],
          "xc_functional": {
            "spin": user_dict["DFT"]["spin"],
            "gamma": user_dict["DFT"]["use_gamma"],
            "cutoff": user_dict["DFT"]["density_cutoff"],
            "derivative": user_dict["Derivatives"]["dft"],
            "functionals": func_dict
          }
        }
        if exx:
          fock_0_dict["exchange_operator"] = {
            "screen": False,
            "poisson_prec": user_dict["Precisions"]["poisson_prec"]
          }
      fock_1_dict = {}
      if (user_dict["WaveFunction"]["method"].lower() == "hartree" or
          user_dict["WaveFunction"]["method"].lower() == "hf" or
          user_dict["WaveFunction"]["method"].lower() == "dft"):
        fock_1_dict["coulomb_operator"] = {
          "poisson_prec": user_dict["Precisions"]["poisson_prec"],
          "shared_memory": user_dict["MPI"]["share_coulomb_potential"]
        }
      if user_dict["WaveFunction"]["method"].lower() == "hf":
        fock_1_dict["exchange_operator"] = {
          "screen": False,
          "poisson_prec": user_dict["Precisions"]["poisson_prec"],
        }

      if user_dict["WaveFunction"]["method"].lower() == "dft":
        func_raw = user_dict["DFT"]["functionals"]
        func_dict = []
        exx = False
        for line in func_raw.split('\n'):
          sp = line.split()
          if len(sp) > 0:
            func = sp[0].lower()
            coef = [1.0]
            if len(sp) > 1:
              coef = list(map(float, sp[1:]))
            func_dict.append({
              "name": func,
              "coef": coef[0]
            })
            if func == "exx":
              exx = True
        fock_1_dict["xc_operator"] = {
          "grid_prec": user_dict["Precisions"]["dft_prec"],
          "shared_memory": user_dict["MPI"]["share_xc_potential"],
          "xc_functional": {
            "spin": user_dict["DFT"]["spin"],
            "gamma": user_dict["DFT"]["use_gamma"],
            "cutoff": user_dict["DFT"]["density_cutoff"],
            "derivative": user_dict["Derivatives"]["dft"],
            "functionals": func_dict
          }
        }
        if exx:
          fock_1_dict["exchange_operator"] = {
            "screen": False,
            "poisson_prec": user_dict["Precisions"]["poisson_prec"],
          }

        rsp_dict["fock_operator_0"] = fock_0_dict
        rsp_dict["fock_operator_1"] = fock_1_dict
        program_dict["rsp_calculations"].append(rsp_dict)

# Estimate total energy of a moleucule as the sum of the nuclear charges
# to the power Z^(5/2). This is to get an order of magnitude estimate that
# is used to set the precision parameter in mrchem in case of abs_prec.
def estimate_energy(coords):
  est_en = 0.0
  for line in coords.split('\n'):
    sp = line.split()
    if len(sp) > 0:
      elm = sp[0].lower()
      Z = PT[elm].Z
      est_en += pow(Z, 2.5)
  return est_en

if __name__ == '__main__':
    main()
